-- WALL MONITOR SCRIPT (Sci-Fi UI + Animations)

-- 1. CONFIGURATION
local floors = {
    [1] = { name = "Lobby",   locked = false },
    [2] = { name = "Storage", locked = false },
    [3] = { name = "Roof",    locked = true, pin = "5555" }
}

-- 2. SETUP
local sides = rs.getSides()
local modemFound = false
for _, side in pairs(sides) do
    if peripheral.getType(side) == "modem" then
        rednet.open(side)
        modemFound = true
        break
    end
end
if not modemFound then pcall(rednet.open, "top") end

local mon = peripheral.find("monitor")
if not mon then error("No Monitor Found") end
mon.setTextScale(1)

-- 3. THEME PALETTE (Change these to swap themes!)
local theme = {
    bg = colors.gray,           -- Main Background
    header_bg = colors.cyan,    -- Top Bar Background
    header_text = colors.black, -- Top Bar Text
    btn_bg = colors.black,      -- Button Background
    btn_text = colors.white,    -- Button Text
    btn_lock = colors.red,      -- Locked Floor Text
    highlight = colors.lime,    -- Click Animation Color
    status_text = colors.lightGray
}

-- 4. DRAWING HELPERS
local function clearScreen()
    mon.setBackgroundColor(theme.bg)
    mon.clear()
end

local function drawBox(x, y, w, h, color)
    mon.setBackgroundColor(color)
    for i = y, y + h - 1 do
        mon.setCursorPos(x, i)
        mon.write(string.rep(" ", w))
    end
end

local function centerText(y, text, txtColor, bgColor)
    if bgColor then mon.setBackgroundColor(bgColor) end
    local w, h = mon.getSize()
    local x = math.max(1, math.floor((w - #text) / 2) + 1)
    mon.setCursorPos(x, y)
    mon.setTextColor(txtColor)
    mon.write(text)
end

-- ANIMATION: Flashes a button when clicked
local function animatePress(yPos, color)
    local w, h = mon.getSize()
    -- Draw a box over the button line
    drawBox(2, yPos, w-2, 1, color)
    sleep(0.1) -- Short pause
    -- The main loop will redraw the normal UI immediately after
end

-- 5. MAIN MENU UI
local function drawMainMenu(statusMsg)
    clearScreen()
    local w, h = mon.getSize()
    
    -- DRAW HEADER
    drawBox(1, 1, w, 1, theme.header_bg)
    centerText(1, "ELEVATOR OS", theme.header_text, theme.header_bg)
    
    -- DRAW FLOORS
    for i = 1, #floors do
        local f = floors[i]
        local yPos = 2 + (i * 2) -- Spaced out
        
        -- Draw Button Background
        drawBox(2, yPos, w-2, 1, theme.btn_bg)
        
        mon.setCursorPos(3, yPos)
        if f.locked then
            mon.setTextColor(theme.btn_lock)
            mon.write(i .. ". " .. f.name .. " [L]")
        else
            mon.setTextColor(theme.btn_text)
            mon.write(i .. ". " .. f.name)
        end
    end
    
    -- DRAW STATUS BAR (Bottom)
    mon.setBackgroundColor(theme.bg)
    centerText(h, statusMsg or "READY", theme.status_text)
end

-- 6. KEYPAD UI (Compact & Themed)
local function drawKeypadUI(targetName, currentPin)
    clearScreen()
    local w, h = mon.getSize()
    
    -- Header
    drawBox(1, 1, w, 1, theme.btn_lock)
    centerText(1, "SECURITY: " .. string.sub(targetName, 1, 8), colors.white, theme.btn_lock)
    
    -- PIN Display
    drawBox(2, 3, w-2, 1, colors.black)
    mon.setCursorPos(2, 3)
    mon.setTextColor(colors.white)
    local masked = string.rep("*", #currentPin)
    local padding = math.floor(((w-2) - 4)/2) -- Center the stars
    if padding < 0 then padding = 0 end
    mon.write(string.rep(" ", padding) .. masked)
    
    -- Keypad Buttons
    local startY = 5
    -- Calculate center X for the 3-wide keypad
    local startX = math.floor((w - 11) / 2) + 2
    if startX < 2 then startX = 2 end
    
    local layout = {{7,8,9},{4,5,6},{1,2,3},{-1,0,-2}}
    
    for row = 1, 4 do
        for col = 1, 3 do
            local digit = layout[row][col]
            if digit >= -1 and digit ~= -2 then
                local x = startX + (col-1)*4 -- Spacing 4 makes buttons 3 wide + 1 gap
                local y = startY + (row-1)*2
                
                if y < h then -- Safety check
                    drawBox(x, y, 3, 1, colors.lightGray)
                    mon.setCursorPos(x+1, y)
                    mon.setTextColor(colors.black)
                    if digit == -1 then mon.write("C")
                    else mon.write(tostring(digit)) end
                end
            end
        end
    end
end

-- 7. TROLL SEQUENCE (Themed)
local function runTrollSequence()
    clearScreen()
    mon.setBackgroundColor(colors.red) -- Angry background
    mon.clear()
    mon.setTextColor(colors.white)
    
    centerText(2, "INCORRECT PIN", colors.white, colors.red)
    centerText(4, "Did you actually", colors.white, colors.red)
    centerText(5, "know the password?", colors.white, colors.red)
    
    -- YES / NO
    local w, h = mon.getSize()
    local btnY = h - 2
    
    drawBox(2, btnY, 5, 1, colors.lime)
    mon.setCursorPos(3, btnY)
    mon.setTextColor(colors.black)
    mon.write("YES")
    
    drawBox(w-5, btnY, 4, 1, colors.black)
    mon.setCursorPos(w-4, btnY)
    mon.setTextColor(colors.white)
    mon.write("NO")
    
    while true do
        local e, s, x, y = os.pullEvent("monitor_touch")
        if y == btnY then
            -- YES
            if x >= 2 and x <= 6 then
                clearScreen()
                centerText(5, "Access Granted...", colors.lime)
                sleep(2)
                clearScreen()
                centerText(5, "SIKE!", colors.red)
                sleep(2)
                return
            end
            -- NO
            if x >= w-5 and x <= w-1 then return end
        end
    end
end

-- 8. INPUT LOGIC
local function getKeypadTouch(x, y)
    -- This needs to match the dynamic layout in drawKeypadUI
    -- It's tricky because we centered it.
    -- Simplified approach: Map zones roughly.
    local w, h = mon.getSize()
    local startY = 5
    local row = math.floor((y - startY) / 2) + 1
    
    -- Determine columns based on screen width logic
    -- We used startX + (col-1)*4
    local startX = math.floor((w - 11) / 2) + 2
    if startX < 2 then startX = 2 end
    
    local col = nil
    if x >= startX and x <= startX+2 then col = 1
    elseif x >= startX+4 and x <= startX+6 then col = 2
    elseif x >= startX+8 and x <= startX+10 then col = 3 end
    
    if row >= 1 and row <= 4 and col then
        local layout = {{7,8,9},{4,5,6},{1,2,3},{-1,0,-2}}
        return layout[row][col]
    end
    return nil
end

local function runPinProcess(target)
    local currentPin = ""
    local entering = true
    
    while entering do
        drawKeypadUI(target.name, currentPin)
        local event, side, x, y = os.pullEvent("monitor_touch")
        local digit = getKeypadTouch(x, y)
        
        if digit then
            animatePress(y, theme.highlight) -- Flash the button
            if digit == -1 then currentPin = ""
            elseif digit >= 0 and #currentPin < 4 then
                currentPin = currentPin .. digit
                if #currentPin == 4 then
                    drawKeypadUI(target.name, currentPin)
                    sleep(0.2)
                    if currentPin == target.pin then
                        return true
                    else
                        runTrollSequence()
                        return false
                    end
                end
            end
        end
    end
    return false
end

-- 9. MAIN LOOPS
local myLabel = os.getComputerLabel()
local myFloorID = tonumber(myLabel)

local function runUI()
    while true do
        drawMainMenu("IDLE - Select Floor")
        local event, side, x, y = os.pullEvent("monitor_touch")
        
        -- Check if a floor button row was clicked
        -- Buttons are at: 4, 6, 8 (2 + i*2)
        local idx = (y - 2) / 2
        
        if idx == math.floor(idx) and floors[idx] then
            local target = floors[idx]
            
            -- ANIMATION: Flash the button Green!
            animatePress(y, theme.highlight)
            
            local auth = true
            if target.locked then
                auth = runPinProcess(target)
            end
            
            if auth then
                drawMainMenu("CALLING: " .. target.name)
                rednet.broadcast({ floor = idx }, "elevator_cmd")
                sleep(2) -- Keep the status message visible
            end
        end
    end
end

local function runBeacon()
    while true do
        local e, s, sCh, rCh, msg, dist = os.pullEvent("modem_message")
        if type(msg) == "table" and msg.sProtocol == "elevator_ping" and myFloorID then
             rednet.send(msg.nSender, { floor = myFloorID, range = dist }, "elevator_pong")
        end
    end
end

parallel.waitForAny(runUI, runBeacon)
